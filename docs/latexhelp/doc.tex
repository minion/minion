\section{constraints}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  Minion supports many constraints and these are regularly being
  improved and added to. In some cases multiple implementations of the
  same constraints are provided and we would appreciate additional
  feedback on their relative merits in your problem.

  Minion does not support nesting of constraints, however this can be
  achieved by auxiliary variables and reification.

  Variables can be replaced by constants. You can find out more on
  expressions for variables, vectors, etc. in the section on variables.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  help variables
\end{verbatim}
}
\section{constraints abs}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   abs(x,y)

makes sure that x=|y|, i.e. x is the absolute value of y.
\end{verbatim}
}
\paragraph{Reference}
{\footnotesize
\begin{verbatim}
help constraints abs
\end{verbatim}
}
\section{constraints alldiff}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Forces the input vector of variables to take distinct values.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Suppose the input file had the following vector of variables defined:

DISCRETE myVec[9] {1..9}

To ensure that each variable takes a different value include the
following constraint:

alldiff(myVec)
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
Enforces the same level of consistency as a clique of not equals 
constraints.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See

   help constraints gacalldiff

for the same constraint that enforces GAC.
\end{verbatim}
}
\section{constraints difference}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   difference(x,y,z)

ensures that z=|x-y| in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint can be expressed in a much longer form, this form both avoids
requiring an extra variable, and also gets better propagation. It gets bounds
consistency.
\end{verbatim}
}
\section{constraints diseq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Constrain two variables to take different values.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
Achieves arc consistency.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
diseq(v0,v1)
\end{verbatim}
}
\section{constraints div}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint
 
   div(x,y,z)

ensures that floor(x/y)=z.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint is only available for positive domains x, y and z.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints modulo
\end{verbatim}
}
\section{constraints element}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint 

   element(vec, i, e)

specifies that, in any solution, vec[i] = e and i is in the range 
[0 .. |vec|-1].
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}

Warning: This constraint is not confluent. Depending on the order the
propagators are called in Minion, the number of search nodes may vary when
using element. To avoid this problem, use watchelement instead. More details
below.

The level of propagation enforced by this constraint is not named, however it
works as follows. For constraint vec[i]=e:

- After i is assigned, ensures that min(vec[i]) = min(e) and 
  max(vec[i]) = max(e).

- When e is assigned, removes idx from the domain of i whenever e is not an
  element of the domain of vec[idx].

- When m[idx] is assigned, removes idx from i when m[idx] is not in the domain
  of e.

This level of consistency is designed to avoid the propagator having to scan
through vec, except when e is assigned. It does a quantity of cheap propagation
and may work well in practise on certain problems.

Element is not confluent, which may cause the number of search nodes to vary
depending on the order in which constraints are listed in the input file, or 
the order they are called in Minion. For example, the following input causes
Minion to search 41 nodes.

MINION 3
**VARIABLES**
DISCRETE x[5] {1..5}
**CONSTRAINTS**
element([x[0],x[1],x[2]], x[3], x[4])
alldiff([x])
**EOF**

However if the two constraints are swapped over, Minion explores 29 nodes.
As a rule of thumb, to get a lower node count, move element constraints
to the end of the list.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See the entry 

   constraints watchelement

for details of an identical constraint that enforces generalised arc
consistency.
\end{verbatim}
}
\section{constraints element	extunderscore one}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint element one is identical to element, except that the
vector is indexed from 1 rather than from 0.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See

   help constraints element

for details of the element constraint which is almost identical to this
one.
\end{verbatim}
}
\section{constraints eq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Constrain two variables to take equal values.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
eq(x0,x1)
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
Achieves bounds consistency.
\end{verbatim}
}
\paragraph{Reference}
{\footnotesize
\begin{verbatim}
help constraints minuseq
\end{verbatim}
}
\section{constraints gacalldiff}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Forces the input vector of variables to take distinct values.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Suppose the input file had the following vector of variables defined:

DISCRETE myVec[9] {1..9}

To ensure that each variable takes a different value include the
following constraint:

gacalldiff(myVec)
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint enforces generalized arc consistency.
\end{verbatim}
}
\section{constraints gaclexleq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint

  gaclexleq(vec0, vec1)

  takes two vectors vec0 and vec1 of the same length and ensures that
  vec0 is lexicographically less than or equal to vec1 in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
  This constraints achieves GAC.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints gaclexless

  for a similar constraint with strict lexicographic inequality.
\end{verbatim}
}
\section{constraints gaclexless}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint

  gaclexless(vec0, vec1)

  takes two vectors vec0 and vec1 of the same length and ensures that
  vec0 is lexicographically less than vec1 in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
  This constraint maintains GAC.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints gaclexleq

  for a similar constraint with non-strict lexicographic inequality.
\end{verbatim}
}
\section{constraints gcc}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The Generalized Cardinality Constraint (GCC) constrains the number of each value
that a set of variables can take.

gcc([primary variables], [values of interest], [capacity variables])

For each value of interest, there must be a capacity variable, which specifies
the number of occurrences of the value in the primary variables.

This constraint is new, and its syntax and implementation are not finalised.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Suppose the input file had the following vectors of variables defined:

DISCRETE myVec[9] {1..9}
BOUND cap[9] {0..2}

The following constraint would restrict the occurrence of values 1..9 in myVec
to be at most 2 each initially, and finally equal to the values of the cap
vector.

gcc(myVec, [1,2,3,4,5,6,7,8,9], cap)
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint enforces a hybrid consistency. It reads the bounds of the
capacity variables, then enforces GAC over the primary variables only.  Then the
bounds of the capacity variables are updated using flow algorithms similar to
those proposed by Quimper et al, Improved Algorithms for the Global Cardinality
Constraint.

This constraint provides stronger propagation to the capacity variables than the
gccweak constraint.
\end{verbatim}
}
\section{constraints gccweak}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The Generalized Cardinality Constraint (GCC) (weak variant) constrains the 
number of each value that a set of variables can take.

gccweak([primary variables], [values of interest], [capacity variables])

For each value of interest, there must be a capacity variable, which specifies
the number of occurrences of the value in the primary variables.

This constraint is new, and its syntax and implementation are not finalised.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Suppose the input file had the following vectors of variables defined:

DISCRETE myVec[9] {1..9}
BOUND cap[9] {0..2}

The following constraint would restrict the occurrence of values 1..9 in myVec
to be at most 2 each initially, and finally equal to the values of the cap
vector.

gccweak(myVec, [1,2,3,4,5,6,7,8,9], cap)
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint enforces a hybrid consistency. It reads the bounds of the
capacity variables, then enforces GAC over the primary variables only.  Then the
bounds of the capacity variables are updated by counting values in the domains
of the primary variables.

The consistency over the capacity variables is weaker than the gcc constraint, 
hence the name gccweak.
\end{verbatim}
}
\section{constraints hamming}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   hamming(X,Y,c)

ensures that the hamming distance between X and Y is at least c. That is, that
the size of the set {i | X[i] != y[i]} is greater than or equal to c.
\end{verbatim}
}
\section{constraints ineq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   ineq(x, y, k)

ensures that 

   x <= y + k 

in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
Minion has no strict inequality (<) constraints. However x < y can be
achieved by

   ineq(x, y, -1)
\end{verbatim}
}
\section{constraints lexleq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   lexleq(vec0, vec1)

takes two vectors vec0 and vec1 of the same length and ensures that
vec0 is lexicographically less than or equal to vec1 in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraints achieves GAC.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See also

   help constraints lexless

for a similar constraint with strict lexicographic inequality.
\end{verbatim}
}
\section{constraints lexless}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   lexless(vec0, vec1)

takes two vectors vec0 and vec1 of the same length and ensures that
vec0 is lexicographically less than vec1 in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint maintains GAC.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See also

   help constraints lexleq

for a similar constraint with non-strict lexicographic inequality.
\end{verbatim}
}
\section{constraints litsumgeq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint litsumgeq(vec1, vec2, c) ensures that there exists at least c
distinct indices i such that vec1[i] = vec2[i].
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
A SAT clause {x,y,z} can be created using:

   litsumgeq([x,y,z],[1,1,1],1)

Note also that this constraint is more efficient for smaller values of c. For
large values consider using watchsumleq.
\end{verbatim}
}
\paragraph{Reifiability}
{\footnotesize
\begin{verbatim}
This constraint is not reifiable.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See also

   help constraints watchsumleq
   help constraints watchsumgeq
\end{verbatim}
}
\section{constraints max}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   max(vec, x)

ensures that x is equal to the maximum value of any variable in vec.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See

   help constraints min

for the opposite constraint.
\end{verbatim}
}
\section{constraints min}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   min(vec, x)

ensures that x is equal to the minimum value of any variable in vec.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See

   help constraints max

for the opposite constraint.
\end{verbatim}
}
\section{constraints minuseq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Constraint

   minuseq(x,y)

ensures that x=-y.
\end{verbatim}
}
\paragraph{Reference}
{\footnotesize
\begin{verbatim}
help constraints eq
\end{verbatim}
}
\section{constraints modulo}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint
 
   modulo(x,y,z)

ensures that x%y=z i.e. z is the remainder of dividing x by y.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint is only available for positive domains x, y and z.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints div
\end{verbatim}
}
\section{constraints negativetable}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
An extensional constraint that enforces GAC. The constraint is
specified via a list of disallowed tuples.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
See entry 

   help input negativetable

for how to specify a table constraint in minion input. The only
difference for negativetable is that the specified tuples are
disallowed.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help input table
help input tuplelist
\end{verbatim}
}
\section{constraints occurrence}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   occurrence(vec, elem, count)

ensures that there are count occurrences of the value elem in the
vector vec.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
elem must be a constant, not a variable.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints occurrenceleq
help constraints occurrencegeq
\end{verbatim}
}
\section{constraints occurrencegeq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   occurrencegeq(vec, elem, count)

ensures that there are AT LEAST count occurrences of the value elem in
the vector vec.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
elem and count must be constants
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints occurrence
help constraints occurrenceleq
\end{verbatim}
}
\section{constraints occurrenceleq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   occurrenceleq(vec, elem, count)

ensures that there are AT MOST count occurrences of the value elem in
the vector vec.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
elem and count must be constants
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints occurrence
help constraints occurrencegeq
\end{verbatim}
}
\section{constraints pow}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint
 
   pow(x,y,z)

ensures that x^y=z.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint is only available for positive domains x, y and z.
\end{verbatim}
}
\section{constraints product}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   product(x,y,z)

ensures that z=xy in any solution.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This constraint can be used for (and, in fact, has a specialised
implementation for) achieving boolean AND, i.e. x & y=z can be modelled
as

   product(x,y,z)

The general constraint achieves bounds generalised arc consistency for
positive numbers.
\end{verbatim}
}
\section{constraints reification}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Reification is provided in two forms: reify and reifyimply.

   reify(constraint, r) where r is a 0/1 var

ensures that r is set to 1 if and only if constraint is satisfied. That is, if r
is 0 the constraint must NOT be satisfied; and if r is 1 it must be satisfied as
normal. Conversely, if the constraint is satisfied then r must be 1, and if not
then r must be 0.

   reifyimply(constraint, r)

only checks that if r is set to 1 then constraint must be satisfied. If r is not
1, constraint may be either satisfied or unsatisfied. Furthermore r is never set
by propagation, only by search; that is, satisfaction of constraint does not
affect the value of r.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
ALMOST ALL constraints are are reifiable. Individual constraint entries mention
if the constraint is NOT reifiable.

ALL constraints are reifyimplyable.
\end{verbatim}
}
\section{constraints reify}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See
   help constraints reification
\end{verbatim}
}
\section{constraints reifyimply}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See
   help constraints reification
\end{verbatim}
}
\section{constraints sumgeq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   sumgeq(vec, c)

ensures that sum(vec) >= c.
\end{verbatim}
}
\section{constraints sumleq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   sumleq(vec, c)

ensures that sum(vec) <= c.
\end{verbatim}
}
\section{constraints table}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
An extensional constraint that enforces GAC. The constraint is
specified via a list of tuples.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
To specify a constraint over 3 variables that allows assignments
(0,0,0), (1,0,0), (0,1,0) or (0,0,1) do the following.

1) Add a tuplelist to the **TUPLELIST** section, e.g.:

**TUPLELIST**
myext 4 3
0 0 0
1 0 0
0 1 0
0 0 1

N.B. the number 4 is the number of tuples in the constraint, the 
number 3 is the -arity.

2) Add a table constraint to the **CONSTRAINTS** section, e.g.:

**CONSTRAINTS**
table(myvec, myext)

and now the variables of myvec will satisfy the constraint myext.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
The constraints extension can also be specified in the constraint
definition, e.g.:

table(myvec, {<0,0,0>,<1,0,0>,<0,1,0>,<0,0,1>})
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help input tuplelist
help input negativetable
\end{verbatim}
}
\section{constraints w-inrange}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint w-inrange(x, [a,b]) ensures that a <= x <= b.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints w-notinrange
\end{verbatim}
}
\section{constraints w-inset}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint w-inset(x, [a1,...,an]) ensures that x belongs to the set 
{a1,..,an}.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints w-notinset
\end{verbatim}
}
\section{constraints w-literal}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint w-literal(x, a) ensures that x=a.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints w-notliteral
\end{verbatim}
}
\section{constraints w-notinrange}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint w-notinrange(x, [a,b]) ensures that x < a or b < x.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints w-inrange
\end{verbatim}
}
\section{constraints w-notinset}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint w-notinset(x, [a1,...,an]) ensures that x does not belong to the
set {a1,..,an}.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints w-inset
\end{verbatim}
}
\section{constraints w-notliteral}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint w-notliteral(x, a) ensures that x =/= a.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints w-literal
\end{verbatim}
}
\section{constraints watched-and}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

  watched-and({C1,...,Cn})

ensures that the constraints C1,...,Cn are all true.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
pointless, bearing in mind that a CSP is simply a conjunction of constraints
already! However sometimes it may be necessary to use a conjunction as a child
of another constraint, for example in a reification:

   reify(watched-and({...}),r)
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints watched-or
\end{verbatim}
}
\section{constraints watched-or}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

  watched-or({C1,...,Cn})

ensures that at least one of the constraints C1,...,Cn is true.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints watched-and
\end{verbatim}
}
\section{constraints watchelement}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint 

   watchelement(vec, i, e)

specifies that, in any solution, vec[i] = e and i is in the range 
[0 .. |vec|-1].
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
Enforces generalised arc consistency.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See entry

   help constraints element

for details of an identical constraint that enforces a lower level of
consistency.
\end{verbatim}
}
\section{constraints watchelement	extunderscore one}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
This constraint is identical to watchelement, except the vector
is indexed from 1 rather than from 0.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See entry

   help constraints watchelement

for details of watchelement which watchelement_one is based on.
\end{verbatim}
}
\section{constraints watchless}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint watchless(x,y) ensures that x is less than y.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints ineq
\end{verbatim}
}
\section{constraints watchsumgeq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint watchsumgeq(vec, c) ensures that sum(vec) >= c.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
  For this constraint, small values of c are more efficient.

  Equivalent to litsumgeq(vec, [1,...,1], c), but faster.

  This constraint works on 0/1 variables only.
\end{verbatim}
}
\paragraph{Reifiability}
{\footnotesize
\begin{verbatim}
  This constraint is not reifiable.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints watchsumleq 
  help constraints litsumgeq
\end{verbatim}
}
\section{constraints watchsumleq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
  The constraint watchsumleq(vec, c) ensures that sum(vec) <= c.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
  Equivalent to litsumgeq([vec1,...,vecn], [0,...,0], n-c) but faster.

  This constraint works on binary variables only.

  For this constraint, large values of c are more efficient.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
  See also

  help constraints watchsumgeq 
  help constraints litsumgeq
\end{verbatim}
}
\section{constraints watchvecneq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   watchvecneq(A, B)

ensures that A and B are not the same vector, i.e., there exists some index i
such that A[i] != B[i].
\end{verbatim}
}
\section{constraints weightedsumgeq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   weightedsumgeq(constantVec, varVec, total)

ensures that constantVec.varVec >= total, where constantVec.varVec is
the scalar dot product of constantVec and varVec.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints weightedsumleq
help constraints sumleq
help constraints sumgeq
\end{verbatim}
}
\section{constraints weightedsumleq}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The constraint

   weightedsumleq(constantVec, varVec, total)

ensures that constantVec.varVec <= total, where constantVec.varVec is
the scalar dot product of constantVec and varVec.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints weightedsumgeq
help constraints sumleq
help constraints sumgeq
\end{verbatim}
}
\section{input}
\paragraph{Description}
{\footnotesize
\begin{verbatim}

Minion expects to be provided with the name of an input file as an
argument. This file contains a specification of the CSP to be solved
as well as settings that the search process should use. The format is

Minion3Input::= MINION 3
                <InputSection>+
                **EOF**

InputSection::= <VariablesSection> 
              | <SearchSection>
              | <ConstraintsSection> 
              | <TuplelistSection>

i.e. 'MINION 3' followed by any number of variable, search,
constraints and tuplelists sections (can repeat) followed by
'**EOF**', the end of file marker.

All text from a '#' character to the end of the line is ignored.

See the associated help entries below for information on each section.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
You can give an input file via standard input by specifying '--' as the file
name, this might help when minion is being used as a tool in a shell script or
for compressed input, e.g.,

   gunzip -c myinput.minion.gz | minion
\end{verbatim}
}
\section{input constraints}
\paragraph{Description}
{\footnotesize
\begin{verbatim}

The constraints section consists of any number of constraint
declarations on separate lines.

ConstraintsSection::= **CONSTRAINTS**
                      <ConstraintDeclaration>*
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
**CONSTRAINTS**
eq(bool,0)
alldiff(d)
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See help entries for individual constraints under

   help constraints

for details on constraint declarations.
\end{verbatim}
}
\section{input example}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Below is a complete minion input file with commentary, as an example.

MINION 3

# While the variable section doesn't have to come first, you can't 
# really do anything until
# You have one...
**VARIABLES**

# There are 4 type of variables
BOOL bool         # Boolean don't need a domain
BOUND b {1..3}    # Bound vars need a domain given as a range
DISCRETE d {1..3} # So do discrete vars

#Note: Names are case sensitive!

# Internally, Bound variables are stored only as a lower and upper bound
# Whereas discrete variables allow any sub-domain

SPARSEBOUND s {1,3,6,7} # Sparse bound variables take a sorted list of values

# We can also declare matrices of variables!

DISCRETE q[3] {0..5} # This is a matrix with 3 variables: q[0],q[1] and q[2]
BOOL bm[2,2] # A 2d matrix, variables bm[0,0], bm[0,1], bm[1,0], bm[1,1]
BOOL bn[2,2,2,2] # You can have as many indices as you like!

#The search section is entirely optional
**SEARCH**

# Note that everything in SEARCH is optional, and can only be given at
# most once!

# If you don't give an explicit variable ordering, one is generated.
# These can take matrices in interesting ways like constraints, see below.
VARORDER [bool,b,d]

# If you don't give a value ordering, 'ascending' is used
#VALORDER [a,a,a,a]

# You can have one objective function, or none at all.
MAXIMISING bool
# MINIMISING x3

# both (MAX/MIN)IMISING and (MAX/MIN)IMIZING are accepted...


# Print statement takes a vector of things to print

PRINT [bool, q]

# You can also give:
# PRINT ALL (the default)
# PRINT NONE


# Declare constraints in this section!
**CONSTRAINTS**

# Constraints are defined in exactly the same way as in MINION input
formats 1 & 2
eq(bool, 0)
eq(b,d)

# To get a single variable from a matrix, just index it
eq(q[1],0)
eq(bn[0,1,1,1], bm[1,1])

# It's easy to get a row or column from a matrix. Just use _ in the
# indices you want
# to vary. Just giving a matrix gives all the variables in that matrix.

#The following shows how flattening occurs...

# [bm] == [ bm[_,_] ] == [ bm[0,0], bm[0,1], bm[1,0], bm[1,1] ]
# [ bm[_,1] ] = [ bm[0,1], bm[1,1] ]
# [ bn[1,_,0,_] = [ bn[1,0,0,0], b[1,0,0,1], b[1,1,0,0], b[1,1,0,1] ]

# You can string together a list of such expressions!

lexleq( [bn[1,_,0,_], bool, q[0]] , [b, bm, d] )

# One minor problem.. you must always put [ ] around any matrix expression, so
# lexleq(bm, bm) is invalid

lexleq( [bm], [bm] ) # This is OK!

# Can give tuplelists, which can have names!
# The input is: <name> <num_of_tuples> <tuple_length> <numbers...>
# The formatting can be about anything..

**TUPLELIST**

Fred 3 3
0 2 3
2 0 3
3 1 3

Bob 2 2 1 2 3 4

#No need to put everything in one section! All sections can be reopened..
**VARIABLES**

# You can even have empty sections.. if you want

**CONSTRAINTS**

#Specify tables by their names..

table([q], Fred)

# Can still list tuples explicitally in the constraint if you want at
# the moment.
# On the other hand, I might remove this altogether, as it's worse than giving
# Tuplelists

table([q],{ <0,2,3>,<2,0,3>,<3,1,3> })

#Must end with the **EOF** marker!

**EOF**

Any text down here is ignored, so you can write whatever you like (or
nothing at all...)
\end{verbatim}
}
\section{input search}
\paragraph{Description}
{\footnotesize
\begin{verbatim}

Inside the search section one can specify

- variable orderings, 
- value orderings,
- optimisation function, and
- details of how to print out solutions.

   SearchSection::= <VarValOrdering>*
                    <OptimisationFn>?
                    <PrintFormat>?

If no varval ordering is given then the variables are assigned in instantiation
order and the values tried in ascending order.

If a variable order is given as a command line argument it will override
anything specified in the input file.

Multiple variable orders can be given, each with an optional value ordering:

   VarValOrdering::= <VarOrder> 
                     <ValOrder>?

In each VarOrder an instantiation order is specified for a subset of
variables. Variables can optionally be \"auxiliary variables\" (add \"AUX\" to
the varorder) meaning that if there are several solutions to the problem
differing only in the auxiliary variables, only one is reported by minion.

   VarOrder::= VARORDER AUX? <ORDER>? [ <varname>+ ]

      where

   <ORDER>::= STATIC | SDF | SRF | LDF | ORIGINAL | WDEG | CONFLICT | DOMOVERWDEG

The value ordering allows the user to specify an instantiation order
for the variables involved in the variable order, either ascending (a)
or descending (d) for each. When no value ordering is specified, the
default is to use ascending order for every search variable.

   ValOrder::= VALORDER[ (a|d)+ ]

To model an optimisation problem the user can specify to minimise
or maximise a variable's value.

   OptimisationFn::= MAXIMISING <varname>
                   | MINIMISING <varname>

Finally, the user can control some aspects of the way solutions are
printed. By default (no PrintFormat specified) all the variables are
printed in declaration order. Alternatively a custom vector, or ALL
variables, or no (NONE) variables can be printed. If a matrix or, more
generally, a tensor is given instead of a vector, it is automatically
flattened into a vector as described in 'help variables vectors'.

   PrintFormat::= PRINT <vector>
                | PRINT ALL
                | PRINT NONE
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See also

   switches -varorder
\end{verbatim}
}
\section{input tuplelist}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
In a tuplelist section lists of allowed tuples for table constraints
can be specified. This technique is preferable to specifying the
tuples in the constraint declaration, since the tuplelists can be
shared between constraints and named for readability.

The required format is

TuplelistSection::= **TUPLELIST**
                    <Tuplelist>*

Tuplelist::= <name> <num_tuples> <tuple_length> <numbers>+
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
**TUPLELIST**
AtMostOne 4 3
0 0 0
0 0 1
0 1 0
1 0 0
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help constraints table
\end{verbatim}
}
\section{input variables}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
The variables section consists of any number of variable declarations
on separate lines.

VariablesSection::= **VARIABLES**
                    <VarDeclaration>*
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
 **VARIABLES**

BOOL bool                          #boolean var
BOUND b {1..3}                     #bounds var
SPARSEBOUND myvar {1,3,4,6,7,9,11} #sparse bounds var
DISCRETE d[3] {1..3}               #array of discrete vars
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
See the help section

   help variables

for detailed information on variable declarations.
\end{verbatim}
}
\section{switches}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Minion supports a number of switches to augment default behaviour.  To
see more information on any switch, use the help system. The list
below contains all available switches. For example to see help on
-quiet type something similar to

   minion help switches -quiet

replacing 'minion' by the name of the executable you're using.
\end{verbatim}
}
\section{switches -X-prop-node}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Allows the user to choose the level of consistency to be enforced
during search.

See entry 'help switches -preprocess' for details of the available
levels of consistency.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
To enforce SSAC during search:

   minion -X-prop-node SSAC input.minion
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -preprocess
\end{verbatim}
}
\section{switches -check}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Check solutions for correctness before printing them out.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This option is the default for DEBUG executables.
\end{verbatim}
}
\section{switches -cpulimit}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
To stop search after N seconds (CPU time), do

   minion -cpulimit N myinput.minion
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -timelimit
help switches -nodelimit
help switches -searchlimit
help switches -sollimit
\end{verbatim}
}
\section{switches -dumptree}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Print out the branching decisions and variable states at each node.
\end{verbatim}
}
\section{switches -findallsols}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Find all solutions and count them. This option is ignored if the
problem contains any minimising or maximising objective.
\end{verbatim}
}
\section{switches -fullprop}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Disable incremental propagation.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This should always slow down search while producing exactly the same
search tree.

Only available in a DEBUG executable.
\end{verbatim}
}
\section{switches -nocheck}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Do not check solutions for correctness before printing them out.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
This option is the default on non-DEBUG executables.
\end{verbatim}
}
\section{switches -nodelimit}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
To stop search after N nodes, do

   minion -nodelimit N myinput.minion
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -cpulimit
help switches -timelimit
help switches -searchlimit
help switches -sollimit
\end{verbatim}
}
\section{switches -noprintsols}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Do not print solutions.
\end{verbatim}
}
\section{switches -noresume}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Do not write a resume file on timeout or being killed.
\end{verbatim}
}
\section{switches -preprocess}
\paragraph{}
{\footnotesize
\begin{verbatim}

This switch allows the user to choose what level of preprocess is
applied to their model before search commences.

The choices are:

- GAC
- generalised arc consistency (default)
- all propagators are run to a fixed point
- if some propagators enforce less than GAC then the model will
not necessarily be fully GAC at the outset

- SACBounds
- singleton arc consistency on the bounds of each variable
- AC can be achieved when any variable lower or upper bound is a
singleton in its own domain

- SAC
- singleton arc consistency
- AC can be achieved in the model if any value is a singleton in
its own domain

- SSACBounds
- singleton singleton bounds arc consistency
- SAC can be achieved in the model when domains are replaced by either
the singleton containing their upper bound, or the singleton containing
their lower bound

- SSAC
- singleton singleton arc consistency
- SAC can be achieved when any value is a singleton in its own domain

These are listed in order of roughly how long they take to
achieve. Preprocessing is a one off cost at the start of search. The
success of higher levels of preprocessing is problem specific; SAC
preprocesses may take a long time to complete, but may reduce search
time enough to justify the cost.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
To enforce SAC before search:

   minion -preprocess SAC myinputfile.minion
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -X-prop-node
\end{verbatim}
}
\section{switches -printsols}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Print solutions.
\end{verbatim}
}
\section{switches -printsolsonly}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Print only solutions and a summary at the end.
\end{verbatim}
}
\section{switches -quiet}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Do not print parser progress.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -verbose
\end{verbatim}
}
\section{switches -randomiseorder}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Randomises the ordering of the decision variables. If the input file
specifies as ordering it will randomly permute this. If no ordering is
specified a random permutation of all the variables is used.
\end{verbatim}
}
\section{switches -randomseed}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Set the pseudorandom seed to N. This allows 'random' behaviour to be
repeated in different runs of minion.
\end{verbatim}
}
\section{switches -redump}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Print the minion input instance file to standard out. No search is
carried out when this switch is used.
\end{verbatim}
}
\section{switches -resume-file}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Resume solving from a resume file.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
To resume the solving of problem.minion from the file resume.minion do

   minion -resume-file resume.minion problem.minion
\end{verbatim}
}
\section{switches -searchlimit}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
To stop search after N seconds search time (real time), do

   minion -searchlimit N myinput.minion

This does not include any time spent in preprocessing.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -timelimit
help switches -cpulimit
help switches -nodelimit
help switches -sollimit
\end{verbatim}
}
\section{switches -sollimit}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
To stop search after N solutions have been found, do

   minion -sollimit N myinput.minion
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -cpulimit
help switches -nodelimit
help switches -searchlimit
help switches -timelimit
\end{verbatim}
}
\section{switches -solsout}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Append all solutionsto a named file.
Each solution is placed on a line, with no extra formatting.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
To add the solutions of myproblem.minion to mysols.txt do

   minion -solsout mysols.txt myproblem.minion
\end{verbatim}
}
\section{switches -tableout}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Append a line of data about the current run of minion to a named file.
This data includes minion version information, arguments to the
executable, build and solve time statistics, etc. See the file itself
for a precise schema of the supplied information.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
To add statistics about solving myproblem.minion to mystats.txt do

   minion -tableout mystats.txt myproblem.minion
\end{verbatim}
}
\section{switches -timelimit}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
To stop search after N seconds (real time), do

   minion -timelimit N myinput.minion
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -cpulimit
help switches -nodelimit
help switches -searchlimit
help switches -sollimit
\end{verbatim}
}
\section{switches -varorder}
\paragraph{Description}
{\footnotesize
\begin{verbatim}

Enable a particular variable ordering for the search process. This
flag is experimental and minion's default ordering might be faster.

The available orders are:

- sdf - smallest domain first, break ties lexicographically

- sdf-random - sdf, but break ties randomly

- srf - smallest ratio first, chooses unassigned variable with smallest
  percentage of its initial values remaining, break ties lexicographically

- srf-random - srf, but break ties randomly

- ldf - largest domain first, break ties lexicographically

- ldf-random - ldf, but break ties randomly

- random - random variable ordering

- static - lexicographical ordering
\end{verbatim}
}
\section{switches -verbose}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Print parser progress.
\end{verbatim}
}
\paragraph{References}
{\footnotesize
\begin{verbatim}
help switches -quiet
\end{verbatim}
}
\section{variables}
\paragraph{General}
{\footnotesize
\begin{verbatim}
Minion supports 4 different variable types, namely

- 0/1 variables,
- bounds variables,
- sparse bounds variables, and
- discrete variables.

Sub-dividing the variable types in this manner affords the greatest
opportunity for optimisation. In general, we recommend thinking of the
variable types as a hierarchy, where 1 (0/1 variables) is the most
efficient type, and 4 (Discrete variables) is the least. The
user should use the variable which is the highest in the hierarchy,
yet encompasses enough information to provide a full model for the
problem they are attempting to solve.

Minion also supports use of constants in place of variables, and constant
vectors in place of vectors of variables. Using constants will be at least
as efficient as using variables when the variable has a singleton domain.

See the entry on vectors for information on how vectors, matrices and,
more generally, tensors are handled in minion input. See also the
alias entry for information on how to multiply name variables for
convenience.
\end{verbatim}
}
\section{variables 01}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
01 variables are used very commonly for logical expressions, and for
encoding the characteristic functions of sets and relations. Note that
wherever a 01 variable can appear, the negation of that variable can
also appear. A boolean variable x's negation is identified by !x.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Declaration of a 01 variable called bool in input file:

BOOL bool

Use of this variable in a constraint:

eq(bool, 0) #variable bool equals 0
\end{verbatim}
}
\section{variables alias}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Specifying an alias is a way to give a variable another name. Aliases
appear in the **VARIABLES** section of an input file. It is best
described using some examples:

ALIAS c = a

ALIAS c[2,2] = [[myvar,b[2]],[b[1],anothervar]]
\end{verbatim}
}
\section{variables bounds}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Bounds variables, where only the upper and lower bounds of the domain
are maintained. These domains must be continuous ranges of integers
i.e. holes cannot be put in the domains of the variables.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}

Declaration of a bound variable called myvar with domain between 1
and 7 in input file:

BOUND myvar {1..7}

Use of this variable in a constraint:

eq(myvar, 4) #variable myvar equals 4
\end{verbatim}
}
\section{variables constants}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Minion supports the use of constants anywhere where a variable can be used. For
example, in a constraint as a replacement for a single variable, or a vector of
constants as a replacement for a vector of variables.
\end{verbatim}
}
\paragraph{Examples}
{\footnotesize
\begin{verbatim}
Use of a constant:

   eq(x,1)

Use of a constant vector:

   element([10,9,8,7,6,5,4,3,2,1],idx,e) 
\end{verbatim}
}
\section{variables discrete}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
In discrete variables, the domain ranges between the specified lower and upper
bounds, but during search any domain value may be pruned, i.e., propagation and
search may punch arbitrary holes in the domain.
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Declaration of a discrete variable x with domain {1,2,3,4} in input file:

DISCRETE x {1..4}

Use of this variable in a constraint:

eq(x, 2) #variable x equals 2
\end{verbatim}
}
\section{variables sparsebounds}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
In sparse bounds variables the domain is composed of discrete values
(e.g. {1, 5, 36, 92}), but only the upper and lower bounds of the
domain may be updated during search. Although the domain of these
variables is not a continuous range, any holes in the domains must be
there at time of specification, as they can not be added during the
solving process.
\end{verbatim}
}
\paragraph{Notes}
{\footnotesize
\begin{verbatim}
Declaration of a sparse bounds variable called myvar containing values
{1,3,4,6,7,9,11} in input file:

SPARSEBOUND myvar {1,3,4,6,7,9,11}

Use of this variable in a constraint:
eq(myvar, 3) #myvar equals 3
\end{verbatim}
}
\section{variables vectors}
\paragraph{Description}
{\footnotesize
\begin{verbatim}
Vectors, matrices and tensors can be declared in minion
input. Matrices and tensors are for convenience, as constraints do not
take these as input; they must first undergo a flattening process to
convert them to a vector before use. Additional commas at the end of 
vectors are ignored (see example below).
\end{verbatim}
}
\paragraph{Examples}
{\footnotesize
\begin{verbatim}
A vector of 0/1 variables:

BOOL myvec[5]

A matrix of discrete variables:

DISCRETE sudoku[9,9] {1..9}

A 3D tensor of 0/1s:

BOOL mycube[3,3,2]

One can create a vector from scalars and elements of vectors, etc.:

alldiff([x,y,myvec[1],mymatrix[3,4]])

When a matrix or tensor is constrained, it is treated as a vector
whose entries have been strung out into a vector in index order with
the rightmost index changing most quickly, e.g.

alldiff(sudoku)

is equivalent to

alldiff([sudoku[0,0],...,sudoku[0,8],...,sudoku[8,0],...,sudoku[8,8]])

Furthermore, with indices filled selectively and the remainder filled
with underscores (_) the flattening applies only to the underscore
indices:

alldiff(sudoku[4,_])

is equivalent to

alldiff([sudoku[4,0],...,sudoku[4,8]])

Lastly, one can optionally add square brackets ([]) around an
expression to be flattened to make it look more like a vector:

alldiff([sudoku[4,_]])

is equivalent to

alldiff(sudoku[4,_])
\end{verbatim}
}
\paragraph{Example}
{\footnotesize
\begin{verbatim}
Additional hanging commas at the end of array are ignored, e.g.

lexleq([A,B,C,],[D,E,F,])

is equivalent to 

lexleq([A,B,C],[D,E,F])

This feature is provided to make it easier to computer-generate input
files.
\end{verbatim}
}
